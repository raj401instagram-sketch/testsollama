name: Ollama Server Ultra-Robust Edition

on:
  workflow_dispatch:
    inputs:
      model:
        description: 'Model to load (e.g., qwen2.5:7b, llama3.1:8b)'
        required: true
        default: 'qwen2.5:0.5b'
        type: choice
        options:
          - 'qwen2.5:0.5b'
          - 'qwen2.5:1.5b'
          - 'qwen2.5:3b'
          - 'qwen2.5:7b'
          - 'llama3.1:8b'
          - 'mistral:7b'
          - 'phi3:mini'
          - 'custom'
      custom_model:
        description: 'Custom model name (if "custom" selected above)'
        required: false
        type: string
      test_prompt:
        description: 'Test prompt after model loads'
        required: false
        default: 'Hello! Please respond with your model name and capabilities.'
        type: string
      keep_alive_minutes:
        description: 'How long to keep server running (5-30 minutes)'
        required: false
        default: '20'
        type: choice
        options:
          - '5'
          - '10'
          - '15'
          - '20'
          - '25'
          - '30'
      tunnel_provider:
        description: 'Tunnel provider to use'
        required: false
        default: 'cloudflare'
        type: choice
        options:
          - 'cloudflare'
          - 'ngrok'
          - 'both'
      enable_monitoring:
        description: 'Enable enhanced monitoring'
        required: false
        default: 'true'
        type: boolean
      retry_on_failure:
        description: 'Auto-retry on failures'
        required: false
        default: 'true'
        type: boolean

env:
  OLLAMA_HOST: 0.0.0.0:11543
  OLLAMA_MODELS: /home/runner/.ollama/models
  OLLAMA_KEEP_ALIVE: 30m
  OLLAMA_ORIGINS: "*"
  WEBHOOK_URL: ""
  TELEGRAM_BOT_TOKEN: ""
  TELEGRAM_CHAT_ID: ""
  NGROK_AUTH_TOKEN: ""
  CLOUDFLARE_TUNNEL_TOKEN: ""
  MAX_RETRIES: 3
  HEALTH_CHECK_INTERVAL: 30
  MEMORY_THRESHOLD: 90

jobs:
  preflight-checks:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should_proceed: ${{ steps.checks.outputs.proceed }}
      runner_id: ${{ steps.checks.outputs.runner_id }}
      cache_key: ${{ steps.checks.outputs.cache_key }}
    steps:
      - id: checks
        name: 🔍 Pre-flight System Checks
        shell: bash
        run: |
          echo "::group::System Pre-flight Checks"

          RUNNER_OS="${{ runner.os }}"

          RUNNER_ID="runner-$(date +%s)-${GITHUB_RUN_ID}"
          echo "runner_id=$RUNNER_ID" >> $GITHUB_OUTPUT

          AVAILABLE_MEMORY=$(free -m | awk 'NR==2{print $7}')
          AVAILABLE_DISK=$(df -BG / | awk 'NR==2{print $4}' | sed 's/G//')

          echo "📊 System Resources:"
          echo "  Memory Available: ${AVAILABLE_MEMORY}MB"
          echo "  Disk Available: ${AVAILABLE_DISK}GB"

          MODEL="${{ github.event.inputs.model }}"
          if [[ "$MODEL" == "custom" ]]; then
            MODEL="${{ github.event.inputs.custom_model }}"
            if [[ -z "$MODEL" ]]; then
              echo "❌ Custom model name not provided"
              echo "proceed=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

          CACHE_KEY="ollama-${RUNNER_OS}-${MODEL//[:\/]/-}-v3"
          echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT

          if [[ $AVAILABLE_MEMORY -lt 1000 ]]; then
            echo "⚠️ Low memory warning: ${AVAILABLE_MEMORY}MB available"
          fi

          if [[ $AVAILABLE_DISK -lt 5 ]]; then
            echo "❌ Insufficient disk space: ${AVAILABLE_DISK}GB available"
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "✅ Pre-flight checks passed"
          echo "proceed=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  ollama-server:
    needs: preflight-checks
    if: ${{ needs.preflight-checks.outputs.should_proceed == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: 🚀 Checkout Repository
        uses: actions/checkout@v4
        with:
          clean: true

      - name: 🛠️ Setup Environment
        shell: bash
        run: |
          echo "::group::Environment Setup"

          mkdir -p logs/{server,tunnel,monitoring,health}
          mkdir -p /home/runner/.ollama/{models,manifests,blobs}
          chmod -R 755 logs /home/runner/.ollama || true

          touch logs/timeline.log logs/error.log logs/recovery.log
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Environment setup started" >> logs/timeline.log

          trap 'echo "$(date): Error occurred on line $LINENO" >> logs/error.log' ERR

          cat > health_check.sh <<'HEALTH'
#!/bin/bash
OLLAMA_URL="http://0.0.0.0:11543"
MAX_ATTEMPTS=3
ATTEMPT=1
while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
  if curl -sf "$OLLAMA_URL/api/tags" > /dev/null 2>&1; then
    echo "✅ Health check passed"
    exit 0
  fi
  echo "⚠️ Health check attempt $ATTEMPT/$MAX_ATTEMPTS failed"
  ATTEMPT=$((ATTEMPT + 1))
  sleep 2
done
echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
exit 1
HEALTH

          chmod +x health_check.sh

          cat > recovery.sh <<'RECOVERY'
#!/bin/bash
echo "🔧 Attempting recovery..." >> logs/recovery.log
pkill -9 -f ollama 2>/dev/null || true
pkill -9 -f cloudflared 2>/dev/null || true
pkill -9 -f ngrok 2>/dev/null || true
rm -f /tmp/ollama.lock /tmp/*.sock 2>/dev/null || true
sleep 3
nohup ollama serve > logs/server/ollama-recovery.log 2>&1 &
echo $! > logs/ollama.pid
for i in {1..30}; do
  if curl -sf http://0.0.0.0:11543/api/tags > /dev/null 2>&1; then
    echo "✅ Recovery successful" >> logs/recovery.log
    exit 0
  fi
  sleep 2
done
echo "❌ Recovery failed" >> logs/recovery.log
exit 1
RECOVERY

          chmod +x recovery.sh
          echo "::endgroup::"

      - name: 📊 System Information
        shell: bash
        run: |
          echo "::group::System Information"
          cat > logs/system_info.json <<'INFO'
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "runner_id": "${{ needs.preflight-checks.outputs.runner_id }}",
  "os": "$(uname -a)",
  "memory_total": "$(free -h | awk 'NR==2{print $2}')",
  "memory_available": "$(free -h | awk 'NR==2{print $7}')",
  "cpu_count": "$(nproc)",
  "cpu_model": "$(lscpu | grep 'Model name' | cut -d: -f2 | xargs)",
  "disk_available": "$(df -h / | awk 'NR==2{print $4}')",
  "kernel": "$(uname -r)",
  "architecture": "$(uname -m)"
}
INFO
          cat logs/system_info.json | jq '.' 2>/dev/null || cat logs/system_info.json
          echo "::endgroup::"

      - id: cache
        name: 📦 Advanced Cache Management
        shell: bash
        run: |
          echo "::group::Cache Management"
          CACHE_KEY="${{ needs.preflight-checks.outputs.cache_key }}"
          echo "📦 Cache Configuration:"
          echo "  Primary Key: $CACHE_KEY"
          echo "  Restore Keys: ollama-${{ runner.os }}-, ollama-"
          if [[ -d /home/runner/.ollama/models ]]; then
            MODEL_COUNT=$(find /home/runner/.ollama/models -type f 2>/dev/null | wc -l)
            echo "  Existing models found: $MODEL_COUNT files"
            if [[ $MODEL_COUNT -gt 0 ]]; then
              echo "cache_valid=true" >> $GITHUB_OUTPUT
            else
              echo "cache_valid=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "cache_valid=false" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: 📦 Restore Ollama Cache
        uses: actions/cache@v4
        id: cache-ollama
        with:
          path: |
            /home/runner/.ollama
            /usr/local/bin/ollama
            /usr/local/bin/cloudflared
            /home/runner/.cloudflared
          key: ${{ needs.preflight-checks.outputs.cache_key }}
          restore-keys: |
            ollama-${{ runner.os }}-${{ github.event.inputs.model }}-
            ollama-${{ runner.os }}-
            ollama-

      - name: ⬇️ Install Ollama with Fallback
        shell: bash
        run: |
          echo "::group::Ollama Installation"
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Installing Ollama" >> logs/timeline.log

          install_ollama() {
            local method=$1
            echo "🔧 Attempting installation via $method..."
            case $method in
              cached)
                if [[ -f /usr/local/bin/ollama ]] && /usr/local/bin/ollama --version 2>/dev/null; then
                  echo "✅ Using cached Ollama"
                  return 0
                fi
                ;;
              official)
                if curl -fsSL https://ollama.com/install.sh | sh; then
                  echo "✅ Installed via official script"
                  return 0
                fi
                ;;
              direct)
                if wget -q https://github.com/ollama/ollama/releases/latest/download/ollama-linux-amd64 -O /tmp/ollama && \
                   sudo mv /tmp/ollama /usr/local/bin/ollama && \
                   sudo chmod +x /usr/local/bin/ollama; then
                  echo "✅ Installed via direct download"
                  return 0
                fi
                ;;
              package)
                if sudo apt-get update -qq && sudo apt-get install -y ollama; then
                  echo "✅ Installed via package manager"
                  return 0
                fi
                ;;
            esac
            return 1
          }

          for method in cached official direct package; do
            if install_ollama $method; then
              break
            fi
            echo "⚠️ Method $method failed, trying next..."
          done

          if ! command -v ollama &> /dev/null; then
            echo "❌ Failed to install Ollama"
            exit 1
          fi

          ollama --version || true
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Ollama installation completed" >> logs/timeline.log
          echo "::endgroup::"

      - name: 🔧 Install Tunnel Providers
        shell: bash
        env:
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        run: |
          echo "::group::Tunnel Installation"

          install_cloudflared() {
            if [[ -f /usr/local/bin/cloudflared ]] && /usr/local/bin/cloudflared --version 2>/dev/null; then
              echo "✅ Cloudflared already installed"
              return 0
            fi
            echo "📥 Installing Cloudflared with Zero Trust support..."
            if sudo mkdir -p --mode=0755 /usr/share/keyrings && \
               curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | sudo tee /usr/share/keyrings/cloudflare-main.gpg >/dev/null && \
               echo 'deb [signed-by=/usr/share/keyrings/cloudflare-main.gpg] https://pkg.cloudflare.com/cloudflared any main' | sudo tee /etc/apt/sources.list.d/cloudflared.list && \
               sudo apt-get update -qq && sudo apt-get install -y cloudflared; then
              echo "✅ Cloudflared installed via official repository"
              return 0
            fi
            echo "⚠️ Repository install failed, trying direct download..."
            for attempt in {1..3}; do
              if wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb && \
                 sudo dpkg -i cloudflared-linux-amd64.deb 2>/dev/null || sudo apt-get install -f -y; then
                echo "✅ Cloudflared installed via direct download"
                return 0
              fi
              echo "⚠️ Direct download attempt $attempt failed"
              sleep 2
            done
            return 1
          }

          install_ngrok() {
            if [[ -z "${NGROK_AUTH_TOKEN}" ]]; then
              echo "ℹ️ Ngrok token not provided, skipping"
              return 0
            fi
            echo "📥 Installing ngrok..."
            if curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null && \
               echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list && \
               sudo apt-get update -qq && sudo apt-get install -y ngrok; then
              ngrok config add-authtoken "${NGROK_AUTH_TOKEN}"
              echo "✅ Ngrok installed and configured"
              return 0
            fi
            return 1
          }

          TUNNEL_PROVIDER="${{ github.event.inputs.tunnel_provider }}"

          if [[ "$TUNNEL_PROVIDER" == "cloudflare" ]] || [[ "$TUNNEL_PROVIDER" == "both" ]]; then
            install_cloudflared || echo "⚠️ Cloudflared installation failed"
          fi

          if [[ "$TUNNEL_PROVIDER" == "ngrok" ]] || [[ "$TUNNEL_PROVIDER" == "both" ]]; then
            install_ngrok || echo "⚠️ Ngrok installation failed"
          fi

          echo "::endgroup::"

      - name: 🧹 Cleanup Environment
        shell: bash
        run: |
          echo "::group::Environment Cleanup"

          safe_kill() {
            local process=$1
            local pids=$(pgrep -f "$process" 2>/dev/null || true)
            if [[ ! -z "$pids" ]]; then
              echo "🔪 Terminating $process processes: $pids"
              for pid in $pids; do
                kill -TERM $pid 2>/dev/null || true
              done
              sleep 2
              for pid in $pids; do
                if kill -0 $pid 2>/dev/null; then
                  echo "⚠️ Force killing $pid"
                  kill -9 $pid 2>/dev/null || true
                fi
              done
            fi
          }

          safe_kill "ollama"
          safe_kill "cloudflared"
          safe_kill "ngrok"

          rm -f /tmp/ollama.* /tmp/*.sock 2>/dev/null || true

          for port in 11543 11434 4040; do
            if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
              echo "🔧 Freeing port $port"
              fuser -k $port/tcp 2>/dev/null || true
            fi
          done

          echo "✅ Environment cleaned"
          echo "::endgroup::"

      - id: start-ollama
        name: 🚀 Start Ollama Server with Health Monitoring
        shell: bash
        run: |
          echo "::group::Starting Ollama Server"
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Starting Ollama server" >> logs/timeline.log

          export OLLAMA_HOST="${OLLAMA_HOST:-0.0.0.0:11543}"
          export OLLAMA_MODELS="${OLLAMA_MODELS:-/home/runner/.ollama/models}"
          export OLLAMA_ORIGINS="${OLLAMA_ORIGINS:-'*'}"
          export OLLAMA_KEEP_ALIVE="${OLLAMA_KEEP_ALIVE:-30m}"
          export OLLAMA_NUM_PARALLEL=4
          export OLLAMA_MAX_LOADED_MODELS=2

          start_ollama() {
            echo "🚀 Starting Ollama server (attempt $1)..."
            nohup ollama serve > logs/server/ollama-$1.log 2>&1 &
            local pid=$!
            echo $pid > logs/ollama.pid
            for i in {1..60}; do
              if curl -sf http://0.0.0.0:11543/api/tags >/dev/null 2>&1; then
                echo "✅ Ollama server started (PID: $pid)"
                return 0
              fi
              if ! kill -0 $pid 2>/dev/null; then
                echo "❌ Ollama process died"
                cat logs/server/ollama-$1.log | tail -20
                return 1
              fi
              echo "⏳ Waiting for Ollama... ($i/60)"
              sleep 2
            done
            echo "❌ Ollama failed to respond"
            return 1
          }

          SUCCESS=false
          for attempt in {1..3}; do
            if start_ollama $attempt; then
              SUCCESS=true
              break
            fi
            echo "⚠️ Start attempt $attempt failed"
            if [[ $attempt -lt 3 ]]; then
              ./recovery.sh || true
              sleep 5
            fi
          done

          if [[ "$SUCCESS" != "true" ]]; then
            echo "❌ Failed to start Ollama after 3 attempts"
            exit 1
          fi

          echo "📋 Testing Ollama API..."
          curl -v http://0.0.0.0:11543/api/tags 2>&1 | head -20 || true

          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Ollama server started successfully" >> logs/timeline.log
          echo "::endgroup::"

      - id: setup-tunnels
        name: 🌐 Setup Tunnels with Zero Trust
        shell: bash
        env:
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
        run: |
          echo "::group::Setting up Tunnels"
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Setting up tunnels" >> logs/timeline.log

          TUNNEL_PROVIDER="${{ github.event.inputs.tunnel_provider }}"

          setup_cloudflare_zerotrust() {
            if [[ -z "${CLOUDFLARE_TUNNEL_TOKEN}" ]]; then
              echo "ℹ️ Cloudflare Zero Trust token not provided, falling back to quick tunnel"
              return 1
            fi
            echo "🌐 Starting Cloudflare Zero Trust tunnel..."
            mkdir -p /home/runner/.cloudflared
            nohup cloudflared tunnel run --token "${CLOUDFLARE_TUNNEL_TOKEN}" > logs/tunnel/cloudflare-zerotrust.log 2>&1 &
            local pid=$!
            echo $pid > logs/cloudflare-zerotrust.pid
            for i in {1..60}; do
              if [[ -f logs/tunnel/cloudflare-zerotrust.log ]]; then
                if grep -q "Connection.*registered" logs/tunnel/cloudflare-zerotrust.log; then
                  local url
                  url=$(grep -oE 'https://[a-zA-Z0-9-]*\.cfargotunnel\.com' logs/tunnel/cloudflare-zerotrust.log | head -1 || true)
                  if [[ -z "$url" ]]; then
                    url="https://ollama-server.cfargotunnel.com"
                  fi
                  sleep 5
                  if curl -sf "$url/api/tags" --max-time 15 >/dev/null 2>&1; then
                    echo "✅ Cloudflare Zero Trust tunnel: $url"
                    echo "$url" > logs/cloudflare_zerotrust_url.txt
                    return 0
                  else
                    echo "⚠️ Tunnel established but API not responding"
                  fi
                fi
              fi
              if ! kill -0 $pid 2>/dev/null; then
                echo "❌ Cloudflare Zero Trust tunnel process died"
                cat logs/tunnel/cloudflare-zerotrust.log | tail -20
                return 1
              fi
              echo "⏳ Waiting for Zero Trust tunnel... ($i/60)"
              sleep 3
            done
            return 1
          }

          setup_cloudflare_quick() {
            echo "🌐 Starting Cloudflare quick tunnel..."
            nohup cloudflared tunnel --url http://0.0.0.0:11543 --no-autoupdate --metrics 0.0.0.0:11544 > logs/tunnel/cloudflare.log 2>&1 &
            local pid=$!
            echo $pid > logs/cloudflare.pid
            for i in {1..90}; do
              if [[ -f logs/tunnel/cloudflare.log ]]; then
                local url
                url=$(grep -oE 'https://[a-zA-Z0-9-]*\.trycloudflare\.com' logs/tunnel/cloudflare.log | head -1 || true)
                if [[ ! -z "$url" ]]; then
                  sleep 5
                  if curl -sf "$url/api/tags" --max-time 10 >/dev/null 2>&1; then
                    echo "✅ Cloudflare quick tunnel: $url"
                    echo "$url" > logs/cloudflare_url.txt
                    return 0
                  fi
                fi
              fi
              if ! kill -0 $pid 2>/dev/null; then
                echo "❌ Cloudflare tunnel process died"
                cat logs/tunnel/cloudflare.log | tail -20
                return 1
              fi
              echo "⏳ Waiting for Cloudflare tunnel... ($i/90)"
              sleep 2
            done
            return 1
          }

          setup_ngrok() {
            if [[ -z "${NGROK_AUTH_TOKEN}" ]]; then
              echo "ℹ️ Ngrok not configured"
              return 1
            fi
            echo "🌐 Starting ngrok tunnel..."
            nohup ngrok http 11543 --log=stdout > logs/tunnel/ngrok.log 2>&1 &
            local pid=$!
            echo $pid > logs/ngrok.pid
            sleep 5
            for i in {1..30}; do
              local url
              url=$(curl -s http://localhost:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url' 2>/dev/null | sed 's/^http:/https:/' || true)
              if [[ ! -z "$url" ]] && [[ "$url" != "null" ]]; then
                echo "✅ Ngrok tunnel: $url"
                echo "$url" > logs/ngrok_url.txt
                return 0
              fi
              if ! kill -0 $pid 2>/dev/null; then
                echo "❌ Ngrok process died"
                return 1
              fi
              echo "⏳ Waiting for ngrok... ($i/30)"
              sleep 2
            done
            return 1
          }

          CF_ZEROTRUST_SUCCESS=false
          CF_QUICK_SUCCESS=false
          NGROK_SUCCESS=false

          if [[ "$TUNNEL_PROVIDER" == "cloudflare" ]] || [[ "$TUNNEL_PROVIDER" == "both" ]]; then
            if setup_cloudflare_zerotrust; then
              CF_ZEROTRUST_SUCCESS=true
            else
              echo "⚠️ Zero Trust tunnel failed, trying quick tunnel..."
              setup_cloudflare_quick && CF_QUICK_SUCCESS=true
            fi
          fi

          if [[ "$TUNNEL_PROVIDER" == "ngrok" ]] || [[ "$TUNNEL_PROVIDER" == "both" ]]; then
            setup_ngrok && NGROK_SUCCESS=true
          fi

          PRIMARY_URL=""
          TUNNEL_TYPE=""

          if [[ "$CF_ZEROTRUST_SUCCESS" == "true" ]]; then
            PRIMARY_URL=$(cat logs/cloudflare_zerotrust_url.txt 2>/dev/null || true)
            TUNNEL_TYPE="Cloudflare Zero Trust"
          elif [[ "$CF_QUICK_SUCCESS" == "true" ]]; then
            PRIMARY_URL=$(cat logs/cloudflare_url.txt 2>/dev/null || true)
            TUNNEL_TYPE="Cloudflare Quick"
          elif [[ "$NGROK_SUCCESS" == "true" ]]; then
            PRIMARY_URL=$(cat logs/ngrok_url.txt 2>/dev/null || true)
            TUNNEL_TYPE="Ngrok"
          fi

          if [[ -z "$PRIMARY_URL" ]]; then
            echo "❌ No tunnels established"
            exit 1
          fi

          echo "primary_url=$PRIMARY_URL" >> $GITHUB_OUTPUT
          echo "tunnel_type=$TUNNEL_TYPE" >> $GITHUB_OUTPUT
          echo "🌐 Primary URL ($TUNNEL_TYPE): $PRIMARY_URL"
          echo "$PRIMARY_URL" > logs/tunnel_url.txt
          echo "$TUNNEL_TYPE" > logs/tunnel_type.txt

          echo "📋 All tunnel URLs:"
          [[ "$CF_ZEROTRUST_SUCCESS" == "true" ]] && echo "  🔒 Zero Trust: $(cat logs/cloudflare_zerotrust_url.txt)"
          [[ "$CF_QUICK_SUCCESS" == "true" ]] && echo "  ⚡ Quick Tunnel: $(cat logs/cloudflare_url.txt)"
          [[ "$NGROK_SUCCESS" == "true" ]] && echo "  🚇 Ngrok: $(cat logs/ngrok_url.txt)"

          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Tunnels established" >> logs/timeline.log
          echo "::endgroup::"

      - name: 📥 Load Model with Smart Retry
        shell: bash
        run: |
          echo "::group::Loading Model"
          MODEL="${{ github.event.inputs.model }}"
          if [[ "$MODEL" == "custom" ]]; then
            MODEL="${{ github.event.inputs.custom_model }}"
          fi
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Loading model: $MODEL" >> logs/timeline.log
          echo "📥 Loading model: $MODEL"
          export OLLAMA_HOST=0.0.0.0:11543

          if ollama list 2>/dev/null | grep -q "$MODEL"; then
            echo "✅ Model found in cache"
          else
            echo "📥 Downloading model..."
            monitor_download() {
              local log_file=$1
              local start_time=$(date +%s)
              while true; do
                if [[ -f "$log_file" ]]; then
                  local progress
                  progress=$(grep -oE '[0-9]+%' "$log_file" | tail -1 || true)
                  if [[ ! -z "$progress" ]]; then
                    echo "📊 Download progress: $progress"
                  fi
                  if grep -q -i "success" "$log_file" 2>/dev/null; then
                    echo "✅ Download completed"
                    return 0
                  fi
                  if grep -q -i "error\|failed" "$log_file" 2>/dev/null; then
                    echo "❌ Download error detected"
                    return 1
                  fi
                fi
                local current_time=$(date +%s)
                local elapsed=$((current_time - start_time))
                if [[ $elapsed -gt 1200 ]]; then
                  echo "❌ Download timeout (20 minutes)"
                  return 1
                fi
                sleep 10
              done
            }

            for attempt in {1..3}; do
              echo "📥 Download attempt $attempt/3..."
              timeout 1200 ollama pull "$MODEL" > logs/download-$attempt.log 2>&1 &
              DOWNLOAD_PID=$!
              if monitor_download "logs/download-$attempt.log"; then
                wait $DOWNLOAD_PID || true
                if [[ $? -eq 0 ]]; then
                  echo "✅ Model downloaded successfully"
                  break
                fi
              else
                kill $DOWNLOAD_PID 2>/dev/null || true
              fi
              if [[ $attempt -lt 3 ]]; then
                echo "⚠️ Retrying download..."
                sleep 10
              else
                echo "❌ Failed to download model after 3 attempts"
                exit 1
              fi
            done
          fi

          echo "🔄 Pre-loading model..."
          timeout 60 ollama run "$MODEL" "test" >/dev/null 2>&1 || true

          echo "📋 Loaded models:"
          ollama list || true

          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Model loading completed" >> logs/timeline.log
          echo "::endgroup::"

      - name: 📡 Send Webhook Notification
        if: always()
        continue-on-error: true
        shell: bash
        env:
          WEBHOOK_URL_SECRET: ${{ secrets.WEBHOOK_URL }}
          TELEGRAM_BOT_TOKEN_SECRET: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID_SECRET: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          echo "::group::Sending Notifications"
          WEBHOOK_URL="${WEBHOOK_URL_SECRET:-https://n8n-latest-l4cl.onrender.com/webhook/034c8802-f6d2-4819-b1fc-04b90835c013}"
          TELEGRAM_BOT_TOKEN="${TELEGRAM_BOT_TOKEN_SECRET:-8240064273:AAElB20fRJOpDkg-rqayRaDwxYK30bEFuIw}"
          TELEGRAM_CHAT_ID="${TELEGRAM_CHAT_ID_SECRET:- -1002851408780}"
          TUNNEL_URL="${{ steps.setup-tunnels.outputs.primary_url }}"
          TUNNEL_TYPE="${{ steps.setup-tunnels.outputs.tunnel_type }}"
          MODEL="${{ github.event.inputs.model }}"
          if [[ "$MODEL" == "custom" ]]; then
            MODEL="${{ github.event.inputs.custom_model }}"
          fi
          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')

          cat > webhook_payload.json <<PAY
{
  "event": "ollama_ready",
  "timestamp": "$TIMESTAMP",
  "run_id": "${{ github.run_id }}",
  "repository": "${{ github.repository }}",
  "model": "$MODEL",
  "tunnel": {
    "url": "$TUNNEL_URL",
    "type": "$TUNNEL_TYPE"
  },
  "uptime_minutes": "${{ github.event.inputs.keep_alive_minutes }}",
  "endpoints": {
    "generate": "$TUNNEL_URL/api/generate",
    "chat": "$TUNNEL_URL/api/chat",
    "models": "$TUNNEL_URL/api/tags",
    "embeddings": "$TUNNEL_URL/api/embeddings"
  },
  "workflow_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
}
PAY

          if [[ ! -z "${WEBHOOK_URL}" ]]; then
            echo "📡 Sending webhook..."
            for i in {1..3}; do
              if curl -s -X POST "${WEBHOOK_URL}" -H "Content-Type: application/json" -d @webhook_payload.json --max-time 30 >/dev/null 2>&1; then
                echo "✅ Webhook sent successfully"
                break
              fi
              echo "⚠️ Webhook attempt $i failed"
              sleep 5
            done
          fi

          if [[ ! -z "${TELEGRAM_BOT_TOKEN}" ]] && [[ ! -z "${TELEGRAM_CHAT_ID}" ]]; then
            echo "📱 Sending Telegram notification..."
            MESSAGE="🚀 *Ollama Server Ready*

🔗 URL: $TUNNEL_URL
🌐 Tunnel: $TUNNEL_TYPE
🤖 Model: $MODEL
⏱️ Uptime: ${{ github.event.inputs.keep_alive_minutes }} minutes
🏃 Runner: ${{ needs.preflight-checks.outputs.runner_id }}

🔧 API Endpoints:
• Generate: \`$TUNNEL_URL/api/generate\`
• Chat: \`$TUNNEL_URL/api/chat\`
• Models: \`$TUNNEL_URL/api/tags\`

Access your Ollama server now!"
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -H "Content-Type: application/json" \
              -d "{\"chat_id\":\"${TELEGRAM_CHAT_ID}\",\"text\":\"${MESSAGE}\",\"parse_mode\":\"Markdown\"}" || echo "Telegram notification failed"
          fi
          echo "::endgroup::"

      - name: 🧪 Test Model with Prompt
        if: ${{ github.event.inputs.test_prompt != '' }}
        shell: bash
        run: |
          echo "::group::Testing Model"
          TEST_PROMPT="${{ github.event.inputs.test_prompt }}"
          MODEL="${{ github.event.inputs.model }}"
          if [[ "$MODEL" == "custom" ]]; then
            MODEL="${{ github.event.inputs.custom_model }}"
          fi
          echo "🧪 Testing model with prompt: $TEST_PROMPT"
          RESPONSE=$(curl -s http://0.0.0.0:11543/api/generate -H "Content-Type: application/json" -d "{\"model\":\"$MODEL\",\"prompt\":\"$TEST_PROMPT\",\"stream\":false}" | jq -r '.response' 2>/dev/null || echo "Test failed")
          echo "📝 Model Response:"
          echo "$RESPONSE"
          echo "::endgroup::"

      - name: 📊 Advanced Monitoring System
        if: ${{ github.event.inputs.enable_monitoring == 'true' || github.event.inputs.enable_monitoring == true }}
        shell: bash
        run: |
          echo "::group::Starting Monitoring"
          cat > monitor_advanced.sh <<'MON'
#!/bin/bash
LOG_DIR="logs/monitoring"
mkdir -p "$LOG_DIR"
HEALTH_LOG="$LOG_DIR/health.log"
METRICS_LOG="$LOG_DIR/metrics.json"
ALERT_LOG="$LOG_DIR/alerts.log"
MEMORY_THRESHOLD=90
CPU_THRESHOLD=80
RESPONSE_TIME_THRESHOLD=5000
check_health() {
  local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
  local healthy=true
  local issues=""
  if ! pgrep -f ollama >/dev/null; then
    healthy=false
    issues="$issues ollama_dead"
    echo "❌ [$timestamp] Ollama process not found" >> "$ALERT_LOG"
    if [[ -f recovery.sh ]]; then
      echo "🔧 Attempting automatic recovery..." >> "$ALERT_LOG"
      ./recovery.sh
    fi
  fi
  local start_time=$(date +%s%N)
  if ! curl -sf http://0.0.0.0:11543/api/tags --max-time 5 >/dev/null 2>&1; then
    healthy=false
    issues="$issues api_unresponsive"
    echo "❌ [$timestamp] API not responding" >> "$ALERT_LOG"
  else
    local end_time=$(date +%s%N)
    local response_time=$(( (end_time - start_time) / 1000000 ))
    if [[ $response_time -gt $RESPONSE_TIME_THRESHOLD ]]; then
      echo "⚠️ [$timestamp] Slow API response: ${response_time}ms" >> "$ALERT_LOG"
    fi
  fi
  local mem_percent
  mem_percent=$(free | grep Mem | awk '{print int($3/$2 * 100)}')
  if [[ $mem_percent -gt $MEMORY_THRESHOLD ]]; then
    echo "⚠️ [$timestamp] High memory usage: ${mem_percent}%" >> "$ALERT_LOG"
  fi
  echo "[$timestamp] Health: $healthy, Issues: $issues" >> "$HEALTH_LOG"
  cat > "$METRICS_LOG" <<MET
{
  "timestamp": "$timestamp",
  "healthy": $healthy,
  "memory_percent": $mem_percent,
  "response_time_ms": ${response_time:-0},
  "issues": "$issues"
}
MET
}
while true; do
  check_health
  sleep 30
done
MON
          chmod +x monitor_advanced.sh
          nohup ./monitor_advanced.sh > logs/monitoring/monitor.log 2>&1 &
          echo $! > logs/monitor.pid
          echo "✅ Advanced monitoring started"
          echo "::endgroup::"

      - name: ⏰ Keep Server Alive with Auto-Recovery
        shell: bash
        run: |
          echo "::group::Keep-Alive Loop"
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Starting keep-alive" >> logs/timeline.log
          DURATION=$(( ${{ github.event.inputs.keep_alive_minutes }} * 60 ))
          START_TIME=$(date +%s)
          TUNNEL_URL=$(cat logs/tunnel_url.txt 2>/dev/null || echo "")
          echo "⏰ Keeping server alive for ${{ github.event.inputs.keep_alive_minutes }} minutes"
          echo "🌐 Server URL: $TUNNEL_URL"
          HEALTH_FAILURES=0
          MAX_FAILURES=3
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            REMAINING=$((DURATION - ELAPSED))
            if [[ $REMAINING -le 0 ]]; then
              echo "⏰ Keep-alive duration completed"
              break
            fi
            MINUTES_LEFT=$((REMAINING / 60))
            SECONDS_LEFT=$((REMAINING % 60))
            echo "⏰ Time remaining: ${MINUTES_LEFT}m ${SECONDS_LEFT}s ($(date '+%H:%M:%S'))"
            if ./health_check.sh; then
              HEALTH_FAILURES=0
            else
              HEALTH_FAILURES=$((HEALTH_FAILURES + 1))
              echo "⚠️ Health check failed ($HEALTH_FAILURES/$MAX_FAILURES)"
              if [[ $HEALTH_FAILURES -ge $MAX_FAILURES ]]; then
                echo "🔧 Triggering automatic recovery..."
                if ./recovery.sh; then
                  echo "✅ Recovery successful"
                  HEALTH_FAILURES=0
                else
                  echo "❌ Recovery failed, attempting to continue..."
                fi
              fi
            fi
            if [[ $((ELAPSED % 300)) -lt 30 ]] && [[ $((ELAPSED % 300)) -ge 0 ]]; then
              echo "📊 5-minute status report:"
              if [[ -n "$TUNNEL_URL" ]]; then
                echo "  🌐 Tunnel: $(curl -sf $TUNNEL_URL/api/tags >/dev/null 2>&1 && echo '✅ Active' || echo '❌ Unreachable')"
              else
                echo "  🌐 Tunnel: N/A"
              fi
              echo "  📊 Ollama: $(curl -sf http://0.0.0.0:11543/api/ps 2>/dev/null | jq -r '.models | length' 2>/dev/null || echo '0') models loaded"
            fi
            sleep 30
          done
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Keep-alive completed" >> logs/timeline.log
          echo "::endgroup::"

      - name: 📊 Generate Final Report
        if: always()
        shell: bash
        run: |
          echo "::group::Final Report"
          echo "==================== FINAL STATUS REPORT ===================="
          echo "🕐 Workflow completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          TUNNEL_URL=$(cat logs/tunnel_url.txt 2>/dev/null || echo 'N/A')
          cat > logs/final_report.json <<FR
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "run_id": "${{ github.run_id }}",
  "runner_id": "${{ needs.preflight-checks.outputs.runner_id }}",
  "status": "${{ job.status }}",
  "model": "${{ github.event.inputs.model }}",
  "tunnel_url": "$TUNNEL_URL",
  "uptime_minutes": "${{ github.event.inputs.keep_alive_minutes }}"
}
FR
          cat logs/final_report.json | jq '.' 2>/dev/null || cat logs/final_report.json
          echo ""
          echo "📜 Workflow Timeline:"
          cat logs/timeline.log 2>/dev/null || echo "No timeline available"
          echo "============================================================"
          echo "::endgroup::"

      - name: 🧹 Cleanup and Save State
        if: always()
        shell: bash
        run: |
          echo "::group::Cleanup"
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Starting cleanup" >> logs/timeline.log
          if [[ -f logs/monitor.pid ]]; then
            kill $(cat logs/monitor.pid) 2>/dev/null || true
          fi
          for service in ollama cloudflared ngrok; do
            if [[ -f logs/${service}.pid ]]; then
              PID=$(cat logs/${service}.pid)
              echo "🛑 Stopping $service (PID: $PID)..."
              kill -TERM $PID 2>/dev/null || true
              for i in {1..10}; do
                if ! kill -0 $PID 2>/dev/null; then
                  echo "✅ $service stopped gracefully"
                  break
                fi
                sleep 1
              done
              kill -9 $PID 2>/dev/null || true
            fi
          done
          echo "📦 Cache statistics:"
          du -sh /home/runner/.ollama/* 2>/dev/null || echo "No cache data"
          echo "✅ Cleanup completed"
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - Cleanup completed" >> logs/timeline.log
          echo "::endgroup::"

      - name: 💾 Upload Comprehensive Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ollama-logs-${{ github.run_id }}
          path: |
            logs/
            *.log
            *.json
          retention-days: 7
          if-no-files-found: warn

  post-analysis:
    needs: [preflight-checks, ollama-server]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: 📊 Analyze Run Performance
        shell: bash
        run: |
          echo "::group::Performance Analysis"
          cat > analysis.json <<AN
{
  "run_id": "${{ github.run_id }}",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "status": "${{ needs.ollama-server.result }}",
  "preflight_status": "${{ needs.preflight-checks.result }}",
  "server_status": "${{ needs.ollama-server.result }}"
}
AN
          if [[ "${{ needs.ollama-server.result }}" == "failure" ]]; then
            echo "❌ Run failed - analyzing failure patterns..."
          elif [[ "${{ needs.ollama-server.result }}" == "success" ]]; then
            echo "✅ Run successful - capturing best practices..."
          fi
          echo "::endgroup::"
